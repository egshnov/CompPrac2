import numpy as np

# ============================
# 1. Задание матрицы A
# ============================

# Пример матрицы D (замените на свои данные)
D = np.array([
    [1.0, -3, 5, 7],
    [-3, 9, 11, 13],
    [5, 11, 15, -17],
    [7, 13, -17, 19]
])

# Пример матрицы C (замените на свои данные)
C = np.array([
    [0.5, 0, 1, 1],
    [0, 0.5, 0, 0],
    [1, 0, 0.5, 0],
    [1, 0, 0, 0.5]
])

# Параметр y
y = 1

# Формируем матрицу A по формуле A = D + y * C
A = D + y * C

# ============================
# 2. Метод степенных итераций (Power Method)
# ============================

def power_method(A, tol=1e-6, max_iter=1000):
    """
    Ищет наибольшее собственное число (по модулю) и собственный вектор матрицы A
    методом степенных итераций с заданной точностью tol.
    
    Возвращает:
        lambda_max : приближённое наибольшее собственное значение
        x          : собственный вектор (нормированный)
        num_iter   : число итераций, затраченных для сходимости
    """
    n = A.shape[0]
    
    # Начальный вектор (здесь единичный вектор)
    x = np.ones(n, dtype=float)
    x = x / np.linalg.norm(x)
    
    lambda_old = 0.0
    for k in range(max_iter):
        # Вычисляем y = A*x
        y = A @ x
        
        # Текущее приближение собственного числа
        lambda_new = np.linalg.norm(y)
        
        # Нормируем y для получения следующего вектора
        x = y / lambda_new
        
        # Проверяем сходимость
        if abs(lambda_new - lambda_old) < tol:
            return lambda_new, x, k+1
        
        lambda_old = lambda_new
    
    return lambda_old, x, max_iter

# ============================
# 3. Метод скалярных произведений
# ============================

def scalar_product_method(A, tol=1e-6, max_iter=1000):
    """
    Ищет наибольшее собственное число и собственный вектор матрицы A
    методом скалярных произведений.
    
    Итерации проводятся по схеме:
        x^(k+1) = A * x^(k)
        lambda^(k+1) = <A*x^(k), x^(k)> / <x^(k), x^(k)>
    с нормированием вектора x.
    
    Возвращает:
        lambda_max : приближённое наибольшее собственное значение
        x          : собственный вектор (нормированный)
        num_iter   : число итераций, затраченных для сходимости
    """
    n = A.shape[0]
    
    x = np.ones(n, dtype=float)
    x = x / np.linalg.norm(x)
    
    lambda_old = 0.0
    for k in range(max_iter):
        y = A @ x
        
        # Вычисляем приближённое собственное число по формуле через скалярное произведение:
        lambda_new = np.dot(y, x) / np.dot(x, x)
        
        # Нормируем вектор y
        norm_y = np.linalg.norm(y)
        if norm_y == 0:
            return 0.0, x, k+1
        y = y / norm_y
        
        # Проверяем сходимость
        if abs(lambda_new - lambda_old) < tol:
            return lambda_new, y, k+1
        
        x = y
        lambda_old = lambda_new
    
    return lambda_old, x, max_iter

# ============================
# 4. Основной блок: запуск методов и вывод результатов
# ============================

if __name__ == "__main__":
    # Вывод исходной матрицы A
    print("Матрица A (A = D + y*C) при y = 1:")
    print(A)
    print("\n-------------------------------\n")
    
    # Метод степенных итераций
    lambda_power, eigenvector_power, iter_power = power_method(A, tol=1e-6, max_iter=1000)
    print("Метод степенных итераций:")
    print(f"  Наибольшее собственное число: {lambda_power}")
    print(f"  Собственный вектор (нормированный): {eigenvector_power}")
    print(f"  Число итераций: {iter_power}\n")
    
    # Метод скалярных произведений
    lambda_sp, eigenvector_sp, iter_sp = scalar_product_method(A, tol=1e-6, max_iter=1000)
    print("Метод скалярных произведений:")
    print(f"  Наибольшее собственное число: {lambda_sp}")
    print(f"  Собственный вектор (нормированный): {eigenvector_sp}")
    print(f"  Число итераций: {iter_sp}\n")
    
    # Сравнение числа итераций
    print("-------------------------------")
    print("Сравнение числа итераций:")
    print(f"  Степенной метод: {iter_power} итераций")
    print(f"  Метод скалярных произведений: {iter_sp} итераций")
